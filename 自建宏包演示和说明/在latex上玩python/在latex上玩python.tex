% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig scalefig xverbatim

\documentclass[11pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{11pt}
\newif\ifphone
\phonefalse

\usepackage{myconfig}
\usepackage{mytitle}
\usepackage{mdframed} 


\begin{document}
\frontmatter

\titlea{学编程}
\titleb{在\LaTeX 之上}
\titlec{学编程和linux知识让\LaTeX 更加强大}
\author{万泽}
\authorinfo{作者：湖南常德人氏}
\editor{万泽}
\email{a358003542@gmail.com}
\editorinfo{编者：wanze。}
\version{1.0}
\titleLC

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
开头说的话

%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter


\chapter{matplotlib宏包}
\section{准备工作}
安装python3-matplotlib\\
\verb+sudo apt-get install python3-matplotlib+

\section{第一个例子}
matplotlib.pyplot 提供了一组命令式的函数让它想MATLAB一样工作。
\begin{xverbatim}[129]{matplotlib宏包第一个例子.py}
import matplotlib.pyplot as plt
plt.plot([1,2,3,4])
plt.ylabel('y label')
plt.savefig('figures/第一个例子.png')
\end{xverbatim}

\begin{linefig}{第一个例子}
\end{linefig}

matplotlib.pyplot里面有很多命令来实现类似MATLAB的功能，每个函数对图片进行某些改变。比如创造图片，制造绘图区域，画某些线，加标签等。

matplotlib现在默认输入y值，然后x值默认从0开始。

\begin{xverbatim}[129]{matplotlib宏包第二个例子.py}
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16],'ro')
plt.axis([0,6,0,20])
plt.savefig('figures/第二个例子.png')
\end{xverbatim}

\begin{linefig}{第二个例子}
\end{linefig}

\begin{xverbatim}[129]{matplotlib宏包第三个例子.py}
import numpy as np
import matplotlib.pyplot as plt

t = np.arange(0. , 5. , 0.2)
plt.plot(t,t, 'r--' , t, t**2 , 'bs' , t ,t**3 , 'g^')
plt.savefig('figures/第三个例子.png')
\end{xverbatim}

\begin{linefig}{第三个例子}
\end{linefig}


\chapter{sympy宏包}
test
\begin{mdframed}
\begin{xverbatim}[129]{sympy宏包测试.py}
from sympy import *
x = symbols('x')
a = Integral(x, (x, 1, 2))
s = Eq(a, a.doit())
print('$$'+ latex(s) + '$$')
\end{xverbatim}
\end{mdframed}






























































%\appendix
%
%\addchtoc{附录}
%\chapter*{附录}
%我是个个人编程开发爱好者，之前学过一些C语言和lisp语言，现在学习python语言觉得大部分东西都没有新意了。我记得网上有谁写过一篇文章说世界上只有两种编程语言：一种是C语言；一种是lisp语言。这是很有道理的。在第一章python语言基础介绍中我将很多的引用到这里来说明python语言的一些特性。
%
%作为个人编程开发爱好者，我觉得python语言就是最好最合适的语言。首先是简单，对于那些大型的C语言项目个人爱好者是不大可能短期内看明白的，而lisp语言，好吧它可能更加适合脑细胞过剩的人士使用吧。但是基于python语言的项目都和\LaTeX 编写文档一样简单，管理好宏包，再写写函数之类的就可以了。其次python语言就设计上我觉得确实是做到了采众家之所长，设计上更加的优秀。关于语言的对比我不会多讲了。等你学过C语言和lisp语言就会确实有这种感觉，编程语言都差不多吧，更重要的是这个编程语言提供的宏包（也就是这个语言的社群开发的人很多）——python语言就是这样一种适合个人开发的社群非常活跃的语言。可利用的宏包多，适合个人开发者，设计简单不费脑。这就是python。
%
%\emph{请注意，以下不是C语言和lisp语言的完全教程。}我主要在ubuntu下编程，不可避免有很多linux相关的知识，都放在这里吧。
%
%\chapter{准备工作}
%
%\section{python.py}
%Ubuntu模板文件夹里面新建一个python.py文件，内容如下：
%\begin{xverbatim}{py}
%#!/usr/bin/env python3
%# -*- coding: utf-8 -*-
%
%#前面是序言部分
%##################################
%
%
%###################################
%#程序正式开始
%
%\end{xverbatim}
%
%加上第一行代码，然后
%对这个文件添加可执行权限：\\
%\verb|chmod a+x  whatfilename|
%这样python脚本就可执行了。
%
%第二行的作用是设置文档utf-8编码。
%python3是默认支持Unicode字符的。
%\section{gneay的配置}
%
%
%\section{模板文件管理}
%
%
%
%\chapter{python语言基础}
%
%\section{基本知识介绍}
%\section{变量赋值}
%x=1
%
%x=y=2
%
%\section{计算}
%\verb|+ - * / ** // % #|
%//是整除  
%
%
%
%\section{基本数据结构}
%\section{数值}
%
%\section{字符串}
%单引号
%
%双引号
%
%三引号
%
%\section{列表}
%方括号
%
%\section{数组}
%()
%
%\section{基本操作}
%
%
%
%
%\section{流程控制}
%
%\subsection{条件}
%
%
%\subsection{迭代}
%
%\subsection{循环}
%
%
%\section{扩充数据结构}
%
%\subsection{列表}
%
%list.append   附加
%
%list.insert   插入
%
%list.remvoe 删除
%
%del语句
%
%list.pop  
%
%list.reverse
%
%list.sort
%
%\section{扩充指令}
%
%\subsection{自定义函数}
%
%
%\subsection{lamba函式介绍}
%
%
%
%
%\section{模块化编程}
%前面已经接触了一定的模块的知识，如果说模块是一个py文件，那么所谓的class宏包就是很多个py宏包组成的文件夹罢了。
%
%
%
%\section{math宏包}
%
%\section{random宏包}
%
%\section{time宏包}
%
%
%
%
%
%\chapter{C语言}
%\subsection{转义字符}
%\textbackslash a{} 响铃符 \hspace{4em} \textbackslash b{} 回退符 \hspace{4em} \textbackslash f{} 换页符\\
%\textbackslash n{} 换行符 \hspace{4em} \textbackslash r{} 回车符 \hspace{4em} \textbackslash t{} 横向制表符\\
%\textbackslash v{} 纵向制表符 \hspace{2em} \textbackslash \textbackslash{} 反斜杠\hspace{4em} \textbackslash ?{} 问号\\
%\textbackslash '{} 单引号  \hspace{4em} \textbackslash " 双引号 \hspace{4em} \textbackslash  ooo{} 八进制数\\
% \textbackslash xhh 十六进制数
%
%
%\section{helloworld项目}
%
%\subsection{库的搭建}
%
%\subsection{makefile基础}
%makefile文件里面主要有三种内容：
%%\vspace{1em}
%%    1.变量声明：
%%
%%        变量声明就是一种基本的严格字符替换的操作。
%%
%%        比如在前面声明了：objects=program.o foo.o utils.o
%%
%%        那么在后面出现的所有\$(objects)或者\$\{objects\}都会被自动替换成上面的那个字符序列，而且是严格替换，即不带空格的。
%%\vspace{1em}
%%      2.映射法则
%%\vspace{1em}
%%        3.命令：
%%
%%    映射法则和命令通常都是联合起来组成这样的结构形式：
%%
%%    target...   : prerequisites..
%%
%%             command
%%
%% 
%%
%%    可以简单地理解为通过prerequisites，也就是先决的依赖文件，采取后面描述的相应的命令（这里的命令都是linux里的shell命令）command之后（一般是）生成了文件target。命令的前面都要按以下tab建留一段空白来表示它是命令。
%%
%%    有的target后面并没有先决条件，也就是后面的命令是无条件执行的。
%%
%%    这个结构总的作用就是告诉make，target是不是out of date，具体视它的依赖文件而定，target不存在也视为out of date。然后就是如果过期了，那么更新，就是运行下面的命令来更新。
%    
%\subsection{gcc基础}
%
%\subsection{gdb的调试基础}
%
%\subsection{autoconf基础}
%
%%在/project/hello的主目录下面的makefile文件的内容如下：
%%
%%    prefix = /usr/local
%%
%%exec_prefix = $(prefix)
%%
%%bindir = $(exec_prefix)/bin
%%
%%
%%export prefix
%%
%%export exec_prefix
%%
%%export bindir
%%
%%
%%all clean  install uninstall :    
%%
%%             cd src && $(MAKE) $@
%%
%%
%%
%%.PHONY:  all clean   install uninstall
%%
%%
%%在/project/hello/src目录下面的makefile文件内容如下：
%%
%%
%%all: hello
%%
%%
%%hello: main.c
%%
%%         $(CC)  -o $@ main.c 
%%
%%
%%clean:
%%
%%         rm hello
%%
%%
%%
%%install:
%%
%%         install -d $(bindir)
%%
%%         install -m 0755 hello  $(bindir)
%%
%%
%%uninstall:
%%
%%         rm $(bindir)/hello 
%%
%%
%%.PHONY: all clean  install uninstall
%%
%%
%%我们等下详细说明，先看下运行情况：
%%
%%现在makefile支持这四个命令：make，make install ，make clean和make uninstall。
%%
%%我们从上图可以看出可以直接从终端调用我们生成的程序hello，然后返回“hello，the world！”。
%%
%%
%%    首先我们看主目录下的makefile文件，前面那部分是变量声明，这个等下还会说到。然后是export 变量，这个就是主目录下的主makefile文件可以使用这个命令，意思是将变量和子一级目录下的makefile共享。
%%
%%    然后我们看到
%%
%%all clean  install uninstall :
%%
%%         cd src && $(MAKE) $@
%%
%%
%%.PHONY:  all clean   install uninstall
%%
%%这实际上是一个跳转结构，首先介绍下.PHONY是个什么意思，前面说了每一个target默认都是一个待生成文件，但是.PHONY:后面跟着的target的意思是这些target不用生成文件。那么总的来说这里的all，clean，install，uninstall在这里是些没有依赖文件的不用生成最终target文件的执行命令了。这些执行命令就是前面说的make，make install ，make clean和make uninstall。make的意思实际上就是make all，这两个命令是没有区别的。
%%
%% 
%%
%%    然后我们看到命令，cd src这个很容易理解，就是跳转到src目录中去了。然后&&符号的意思是逻辑与，即前一命令执行完之后再执行后面的命令。而后面的$(MAKE)可能是一个具有系统默认值的变量，在这里应该就是make。而$@符号的意思则是指代当前的target。比如说我现在make clean ，那么命令最终就成了这个样子：
%%
%%    cd src &&make clean
%%
%%    然后下一个make clean的命令实际上是对src子目录下的makefile文件说的，我们看到这里简单的：
%%
%%clean:
%%
%%    rm hello
%%
%%即把生成的可执行文件hello删掉即可。
%%
%% 
%%
%%然后我们再来看子目录下那个makefile文件如何处理make all 命令：
%%
%%all: hello
%%
%%
%%hello: main.c
%%
%%    $(CC)  -o $@ main.c 
%%
%%我们看到，这里首先说明all依赖于hello，然后hello依赖于main.c，而要生成或者更新hello的话需要执行下面的命令：
%%
%%cc -o hello main.c 
%%
%%上面的$(CC)也是具有系统默认值的变量，就是cc，不过在GNU/LINUX体系下可能调用的是gcc工具。后面的选项-o的意思是编译连接然后生成后面的那个名字的文件。名字在这里就是hello。
%%
%%
%%然后我们再来看make install命令执行的情况：
%%
%%install:
%%
%%install -d $(bindir)
%%
%%install -m 0755 hello  $(bindir)
%%
%%前面说过了这个变量是继承自主目录makefile文件中的定义，然后翻译出来$(bindir)就是/usr/local/bin。linux系统在终端可以直接调用的命令存放点有两个位置，另外的一个是/usr/bin。/usr/local文件夹内部的结构和/usr内部的结构非常相似。似乎讲起来/usr是供系统内部的软件使用的空间，但这个规矩并不是死的。
%%
%%
%%uninstall命令我们看到就是一个删除对应位置hello文件的操作。所以现在就把linux中的install命令讲讲就可以了。
%%
%%    第一个install命令接着-d的选项的意思就是目录确认，在这里我觉得有点多余。
%%
%%    第二个install命令接着-m的选项的意思就是把hello复制到指定的目录中去，然后相应文件也就是hello文件的权限设置成为0755.关于权限我觉得在这里似乎也没有什么好说的。在这里用第二个install命令就可以搞定了，过程是复制，加权限，更新时间戳。
%\chapter{linux知识}
%
%\section{在emacs之上}
%好吧，久负盛名的编辑器，我给它单独开了一个分支。
%\subsection{初识emacs}
%\begin{enumerate}
%\item 在emacs中进入终端：（按下左边）alt  +  x  然后输入eshell
%\item 退出eshell：输入exit
%\item 在emacs中进入common-lisp的交互界面：（左边）alt + x +slime
%\item 退出slime模式：按下逗号，然后再按下q 即可
%\item emacs的窗口布局调整：按下左边的ctrl+x，然后再输入1：那么只有一个窗口。按下ctrl+x，然后再输入2：那么在当前窗口下面会再分出一个窗口。而按下ctrl+x，然后在输入3：那么就是在当前窗口右边再分出一个窗口。
%\item 用emacs打开某个文件和编辑之后保存文件：按下ctrl+x，然后在按下ctrl+f，这个时候我们看到emacs最下面显示目前所处路径为～/，然后我们在下面接着填上我们想要打开的文件的目录地址，enter之后我们就看到emacs打开该文件了。然后保存文件：按下ctrl+x ，再按下ctrl+s （前面的f是find的意思，这里的s是save的意思。）如果强行退出emacs的话如果还有没保存的buffer它也会提醒的。
%\end{enumerate}
%
%
%
%
%
%\subsection{配置emacs的slime环境}
%\begin{enumerate}
%\item 首先安装commonlisp的一种编译器，这里以clisp为例子，其实sbcl等也是不错地：\\
%    sudo apt-get install clisp
%\item 安装cvs，然后通过cvs服务器下载最新的slime版本：\\
%    sudo apt-get install cvs
%    
%    cvs -d :pserver:anonymous:anonymous@common-lisp.net:/project/slime/cvsroot co slime
%\item 或者你也可以到slime官网上下载镜像文件，然后解压到你的主文件夹目录之下，\href{http://common-lisp.net/project/slime/}{slime官网}
%\item 配置.emacs文件，加上如下代码：
%\begin{xverbatim}{lisp}
%;;; Always do syntax highlighting
%(global-font-lock-mode 1)
%
%;;; Also highlight parens
%(setq show-paren-delay 0
%      show-paren-style 'parenthesis)
%(show-paren-mode 1)
%;;;下面是scheme的设置部分
%;;; This is the binary name of my scheme implementation
%(setq scheme-program-name "mzscheme")
%
%;;;下面是clisp的slime设置部分
%(add-to-list 'load-path "~/slime")
%(require 'slime)
%(add-hook 'lisp-mode-hook (lambda () (slime-mode t)))
%(add-hook 'inferior-lisp-mode-hook (lambda () (inferior-slime-mode t)))
%;; Optionally, specify the lisp program you are using. Default is "lisp"
%(setq inferior-lisp-program "clisp") 
%(slime-setup '(slime-fancy))
%\end{xverbatim}
%\item 最后进入emacs，按下alt+x，输入slime，即进入common-lisp的交互环境。
%\item 如果你发现加载出现asdf库错误，可能是你以前的slime旧配置作怪,清除以前的旧配置可能有效:\\
%    sudo apt-get purge slime
%\end{enumerate}
%
%
%\subsection{配置emacs的scheme环境}
%\begin{enumerate}
%\item 在ubuntu软件中心安装GNU emacs23.或者终端下输入命令：\\
%    sudo apt-get install emacs23
%\item 安装相应的scheme的编译器,这里推荐guile：\\
%    sudo apt-get install guile-2.0
%\item cd \~{} 
%\item sudo gedit .emacs
%\item 在.emacs文件中添加如下代码：\\
%\begin{xverbatim}{lisp}
%;;; Always do syntax highlighting
%(global-font-lock-mode 1)
%
%;;; Also highlight parens
%(setq show-paren-delay 0
%      show-paren-style 'parenthesis)
%(show-paren-mode 1)
%\end{xverbatim}
%这段代码是语法高亮和括号提示，同样可以作用于其他lisp系的语言，所以可以放在emacs配置文件的最上面。
%\item 然后加上这段专门配置scheme的代码：\\
%\begin{xverbatim}{lisp}
%;;;下面是scheme的设置部分
%
%;; This is the binary name of my scheme implementation
%(setq scheme-program-name "guile")
%\end{xverbatim}
%\item 打开emacs，然后按下alt+x，然后输入run-scheme，即进入sheme的交互环境了。
%\item 退出命令：\\
%    (exit)
%\end{enumerate}
%
%\subsection{emacs的其他配置}
%这里还有一个设置背景色和支持复制粘贴快捷键的配置，还有其他的很多配置以后再慢慢摸索吧。
%\begin{xverbatim}{lisp}
%;;;设置背景色
%(setq default-frame-alist
%  '((tool-bar-lines . 0)
%    (menu-bar-lines . 1)
%    (background-color . "cornsilk")))
%   ;;; 左边显示行数
%(global-linum-mode 1)
%;;;支持复制粘贴快捷键
%(cua-mode 1) 
%\end{xverbatim}
%
%
%
%\chapter{其他资料临时存放地}
%1.刘鑫等人翻译的python入门教程。for python3
%2.主要参考书籍：http://ishare.iask.sina.com.cn/f/18565630.html


%这里空一行

\end{common-format}
\end{document}



