% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig scalefig xverbatim

\documentclass[11pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{11pt}
\newif\ifphone
\phonefalse

\usepackage{myconfig}
\usepackage{mytitle}


\makeatletter
\@addtoreset{@EndnoteCounter}{chapter}
\makeatother


\begin{document}
\frontmatter

\titlea{学编程}
\titleb{在\LaTeX 之上}
\titlec{学编程和linux知识让\LaTeX 更加强大}
\author{万泽}
\authorinfo{作者：湖南常德人氏}
\editor{万泽}
\email{a358003542@gmail.com}
\editorinfo{编者：wanze。}
\version{1.0}
\titleLC

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
开头说的话

%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter


\chapter{matplotlib宏包}
\section{准备工作}
安装python3-matplotlib\\
\verb+sudo apt-get install python3-matplotlib+

\section{第一个例子}
matplotlib.pyplot 提供了一组命令式的函数让它想MATLAB一样工作。
\begin{xverbatim}[0]{py}
import matplotlib.pyplot as plt
plt.plot([1,2,3,4])
plt.ylabel('y label')
plt.savefig('figures/第一个例子.png')
\end{xverbatim}

\begin{fig}{第一个例子}
\end{fig}

matplotlib.pyplot里面有很多命令来实现类似MATLAB的功能，每个函数对图片进行某些改变。比如创造图片，制造绘图区域，画某些线，加标签等。

mapplotlib现在默认输入y值，然后x值默认从0开始。

\begin{xverbatim}[0]{py}
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16],'ro')
plt.axis([0,6,0,20])
plt.savefig('figures/第二个例子.png')
\end{xverbatim}

\begin{fig}{第二个例子}
\end{fig}

\begin{xverbatim}[0]{py}
import numpy as np
import matplotlib.pyplot as plt

t = np.arange(0. , 5. , 0.2)
plt.plot(t,t, 'r--' , t, t**2 , 'bs' , t ,t**3 , 'g^')
plt.savefig('figures/第三个例子.png')
\end{xverbatim}

\begin{linefig}{第三个例子}
\end{linefig}


\chapter{sympy宏包}
test
\begin{xverbatim}[139]{py}
from sympy import *
x = symbols('x')
a = Integral(x, (x, 1, 2))
s = Eq(a, a.doit())
print('$$'+ latex(s) + '$$')
\end{xverbatim}
test






























































%\appendix
%
%\addchtoc{附录}
%\chapter*{附录}
%我是个个人编程开发爱好者，之前学过一些C语言和lisp语言，现在学习python语言觉得大部分东西都没有新意了。我记得网上有谁写过一篇文章说世界上只有两种编程语言：一种是C语言；一种是lisp语言。这是很有道理的。在第一章python语言基础介绍中我将很多的引用到这里来说明python语言的一些特性。
%
%作为个人编程开发爱好者，我觉得python语言就是最好最合适的语言。首先是简单，对于那些大型的C语言项目个人爱好者是不大可能短期内看明白的，而lisp语言，好吧它可能更加适合脑细胞过剩的人士使用吧。但是基于python语言的项目都和\LaTeX 编写文档一样简单，管理好宏包，再写写函数之类的就可以了。其次python语言就设计上我觉得确实是做到了采众家之所长，设计上更加的优秀。关于语言的对比我不会多讲了。等你学过C语言和lisp语言就会确实有这种感觉，编程语言都差不多吧，更重要的是这个编程语言提供的宏包（也就是这个语言的社群开发的人很多）——python语言就是这样一种适合个人开发的社群非常活跃的语言。可利用的宏包多，适合个人开发者，设计简单不费脑。这就是python。
%
%\emph{请注意，以下不是C语言和lisp语言的完全教程。}我主要在ubuntu下编程，不可避免有很多linux相关的知识，都放在这里吧。
%
%\chapter{准备工作}
%
%\section{python.py}
%Ubuntu模板文件夹里面新建一个python.py文件，内容如下：
%\begin{xverbatim}{py}
%#!/usr/bin/env python3
%# -*- coding: utf-8 -*-
%
%#前面是序言部分
%##################################
%
%
%###################################
%#程序正式开始
%
%\end{xverbatim}
%
%加上第一行代码，然后
%对这个文件添加可执行权限：\\
%\verb|chmod a+x  whatfilename|
%这样python脚本就可执行了。
%
%第二行的作用是设置文档utf-8编码。
%python3是默认支持Unicode字符的。
%\section{gneay的配置}
%
%
%\section{模板文件管理}
%
%
%
%\chapter{python语言基础}
%
%\section{基本知识介绍}
%\section{变量赋值}
%x=1
%
%x=y=2
%
%\section{计算}
%\verb|+ - * / ** // % #|
%//是整除  
%
%
%
%\section{基本数据结构}
%\section{数值}
%
%\section{字符串}
%单引号
%
%双引号
%
%三引号
%
%\section{列表}
%方括号
%
%\section{数组}
%()
%
%\section{基本操作}
%
%
%
%
%\section{流程控制}
%
%\subsection{条件}
%
%
%\subsection{迭代}
%
%\subsection{循环}
%
%
%\section{扩充数据结构}
%
%\subsection{列表}
%
%list.append   附加
%
%list.insert   插入
%
%list.remvoe 删除
%
%del语句
%
%list.pop  
%
%list.reverse
%
%list.sort
%
%\section{扩充指令}
%
%\subsection{自定义函数}
%
%
%\subsection{lamba函式介绍}
%
%
%
%
%\section{模块化编程}
%前面已经接触了一定的模块的知识，如果说模块是一个py文件，那么所谓的class宏包就是很多个py宏包组成的文件夹罢了。
%
%
%
%\section{math宏包}
%
%\section{random宏包}
%
%\section{time宏包}
%
%
%
%
%\chapter{common-lisp}
%Common-lisp以下全部都简称lisp，lisp的数据类型分为符号和数字。数字又分为整数integer、实数floatingpoint和ratio分数三类。其中分数都会自动化为最小分母的形式。比如：
%CL-USER 1 > (/ 1 2)
%1/2
% 
%CL-USER 2 > (/ 2 4)
%1/2
% 
%Lisp中的T和nil表示逻辑的真值和假值，然后空表()也表示nil，而其他所有东西在逻辑上都被视作真值。
% 
%一些逻辑上的判断函数，numberp判断是否是数字，symbolp判断是否是符号。Equal判断是否两个值相等。zerop判断是否是0，oddp判断是否是奇数，evenp判断是否是偶数。还有小于号也是一个判断函数<，还有大于号>。not在逻辑上反值。
% 
%举些例子：
% 
%CL-USER 1 > (numberp 2)
%T
% 
%CL-USER 2 > (symbolp 'dog2-dfdf)
%T
% 
%CL-USER 3 > (symbolp '2-1-3-dfdfg)
%T
% 
%CL-USER 4 > (equal 'dog 'dog)
%T
% 
%CL-USER 5 > (< '-4 -3)
%T
% 
%CL-USER 6 > (oddp 3)
%T
% 
%CL-USER 7 > (not '(a d c))
%NIL
% 
%通过上面的例子我们注意到lisp语言的符号几乎是没有什么限制的，除了数字之外就是符号。然后数字前面可以加引用号’，也可以不加。不过符号就一定要加，否则会出错。还有就是即使列表这样的东西在lisp中通过not操作也会返回nil值。
% 
%lisp的一些基本内置函数：
%+  -  *  /  abs    sqrt 
%前面的加减乘除的输入参数可以是任意的输入参数。具体就是第一个数连续加（减 或者乘除）上后面的数。不过加减乘只有一个参数的时候结果是什么都好想想，除法示例如下：
%CL-USER 16 : 2 > (/ 128)
%1/128
% 
%在电脑中cpu的工作可以理解成为硬件化的某些基本函数，比如加减之类的。而其他我们接触到的所有函数都只是输入指针，输出指针。而这些指针的具体内存地址并不永久存在，只是暂时存在在某个寄存器或者堆栈上（因为具体的内存地址也是需要处理之后生成的一个结果）。也就是所有复杂的函数都是架构在最基本的几个硬件函数至上的，所不同的是这些硬件函数会具体根据不同的地址输入不同的待处理信息或者在不同的地址上输出处理后的信息。
%lisp，list processor，中文名字就是链表处理语言。显然，list就是里面最基本的数据结构，而其他所有的数据结构都是基于list架构出来的。一个链表的结构非常简单，就是一个cons cell结构，这个结构由car指针地址和cdr指针地址两个指针地址组成。
%现在演示下(a (b c) d)的结构
% 
% 图片
%现在我们把这个列表简单地命名为list：
%CL-USER 21 : 3 > (setq list '(a (b c) d))
%(A (B C) D)
% 
%CL-USER 22 : 3 > list
%(A (B C) D)
%那么我们首先：
%CL-USER 23 : 3 > (car list)
%A
%在这里发生的什么呢？car函数是如此的基本，在这里list传递给别人的也不是别的，就是它指向那个(a (b c) d)的地址。然后car函数根据这个地址顺藤摸瓜找到了第一个地址，然后根据这个地址找到那段内存的数据，然后返回回来。所以原子（atom）类型的符号是实实在在的一个存储在内存中的信息，这段信息需要用基本函数（primitive function）quote，也就是前面加个’来调用出来。而像上面list通过setq定义的符号就成为了一个变量，这个变量和list不同只是一个指针地址的结构，声明他就自动调用它所映射的在内存中的信息。
%那么cdr函数的工作也就简单了，根据list所提供的地址，顺藤摸瓜找到第一个链表的cdr地址，然后创造一个内存，这个内存中的地址信息指向那个cdr地址。然后将这个值作为返回结果。记住所有的括号在内存中都是不存在，而cdr返回后面部分内容只是基于链表的向后而不能向前查询的内在机制决定的。
% 
%关于car，cdr的诸多衍生如什么caddr之类的就不多说了，记住从右向左看就是的了。
% 
%前面说了再复杂的list结构都是由最基本的cons cell 组成的。所谓cons结构，这个基元细胞就是car地址加上cdr地址这样的组合形式。
%那么内置基本函数cons的功能就是接受两个地址，第一个地址存入car地址，第二个地址存入cdr地址。这样形成一个cons cell的基元结构。
%而内置基本函数list就是迭代调用cons函数的结果。
%CL-USER 28 : 6 > (list 'a 'b 'c)
%(A B C)
% 
%CL-USER 30 : 6 > (cons 'a (cons 'b (cons 'c nil)))
%(A B C)
%所以cons函数首先将c的引用地址和nil组合成一个cons cell 然后返回这个cell的引用地址，然后是b的引用地址和那个返回地址，然后是a的地址和那个返回地址。这样依次形成这样的链表结构：
% 
%图片
%就是如上图所示的过程，然后最后返回这个链表的引用地址。
%下面是一些特殊情况的例子：
%CL-USER 31 : 6 > (length '(a b c))
%3
% 
%CL-USER 32 : 6 > (length nil)
%0
% 
%CL-USER 33 : 6 > (car nil)
%NIL
% 
%CL-USER 34 : 6 > (cdr nil)
%NIL
% 
%还有一些基本的函数，first返回第一个元素，second，third，rest。
%还有两个判断函数，listp和consp。这两个函数大多数情况都一样的，遇到列表返回T，不是返回nil。但是有以下特殊情况。
%CL-USER 36 : 6 > (listp nil)
%T
% 
%CL-USER 37 : 6 > (consp nil)
%NIL
% 
%CL-USER 38 : 6 > (atom nil)
%T
%CL-USER 40 : 6 > (cons nil nil)
%(NIL)
% 
%CL-USER 41 : 6 > (list nil nil)
%(NIL NIL)
%这之间的区别就在于list内置的最后以下会自动加上一个nil，然后nil是空表所以listp判断为真，但是nil并不是cons cell 结构，它是一个原子量。nil比较特殊。
% 
%
%2.lisp用于逻辑线路控制的命令：if，and，or，cond。
%
%2.1  if主要用于逻辑线路不太复杂的情况，用法是：
%（if      逻辑判断部分    是真则执行我   是假则执行我）
%或者只有三个部分，那么就是默认是假的时候什么都不做，即nil。
%
%
%2.2 and 和or
%and是先evaluate一个，如果是真，那么going on to evaluate，如果是nil，那么返回nil。
%and还有一个有趣的性质，那就是如果都为真，那么最后返回的不是T，而是最后那个信息的结果。
%（and 'one  'two 'three)--->three
%
%or是先evaluate一个，如果是真就report，同样返回这个信息的结果，如果是nil，keep going on to search。
%(or nil nil 'apple 'blue)---->apple
%
%or可以建立事物的组合关系，这样对应真实世界的空间关系。也就是抽取一个属性，和某个逻辑判断元比对后，返回这个属性。
%and可以建立事物的序列关系，对应真实世界的时间关系。即依次对比，直到反馈最后一个属性。
%
%2.3  .side effect ，pure lisp 只有cons car cdr equal atom cond lambda define quote eval + - * / 这些命令
%这些命令没有副效应，即不会改变机器的状态。但是其他的宏命令会改变机器的状态。上面的setf就是。
%比如random是一个产生随机数的函数，它为了保证每次运行它都制作一个随机数，它实际上改变了random number generator。
%（random 5）----->从0随机到5，包括0不包括5.
%
%2.4 cond则适用于那些特别大型的逻辑线路。
%下面是一个随机数的条件程序：
% 
%图片
% 
%3.setf ，defun，let和let*
%还有一个setq和setf差不多的，不过一般用setf。
%setf宏命令就是给一个变量variable赋值，通常为global variable。
%（setf  vowels  '(a b c ))
%
%4.let 主要用于创造local  variables.用法如下：
% 
%图片
%上面就是用let 给sum赋值，然后sum是local  variale,即他的存在只在let 这个括号内。
%
%5.let 在body中遇到不认识的变量了，首先在自己内部找，如果找不到，那么在global variable中找。
%然后没定义一个defun其函数内部都有自己独立的语境，即用自己的局域变量，找不到就用广义变量。还找不到就说出现错误。
% 
%图片
%上面例子就显示了我额外加了一个z程序是如何处理的。
%
%6.let*和let的区别就是一次只运算赋值一个本地变量，然后再第二个。也就是说如果第二个的赋值依赖于第一个的话，那么比如用let*。比如说我先赋值r，然后赋值面积等于2 * pai*r，那么第二个赋值就依赖于第二个。这种情况用let就会出现错误。但是编程一般用let，为了竟可能减少程序间的依赖关系，方便理解。
%
%7.用sdraw工具学习common-lisp
%http://www.cs.cmu.edu/~dst/Lisp/sdraw/sdraw.generic
%打开上面的网站。然后复制，然后新建文件，命名为sdraw.generic。
%然后我把这个文件放在我的主文件目录的lisp文件下的下面了。
%所以我现在加载这个文件，然后运行一个简单的例子：
% 
%图片
%这个就是传说中的cons cell结构，这个工具能够直接画出来，good！
%
%8.cons ，list 还有append。
%cons这个命令就是创建cons cell结构，通常用于把元素添加到列表头上。
% 整个过程是先创造一个cons cell，第一个地址指向第一个元素，第二个地址指向第二个元素。
% 
%图片
%
%需要特别说明的就是那个中间加点的结构，叫什么dotted list，意思是它不是以nil结尾的。而是以一个值。
%
%list这个命令好理解点，就是加了一个括号。也就是总是ending in nil。因为括号就是意味这一个标准的cons cell 结构 而且以nil结束。
%
%append命令作用过程是首先复制第一个列表作为input信号，然后将其尾部指向到第二个元素中。
%因此append命令第一个元素必须是列表，否则会出现错误。
%(append 'a '(b c))--->error!!
% 
%图片
%
%9.给列表后面添加一个元素：
% 
%图片
% 
%
% 
% 
%1.更多的列表操作函数：
%reverse               nth                        nthcdr                  last           remove
%上面四个函数都是创建了一个新的列表，原列表对应的变量的值并没有改变。
%
%2.reverse  将列表第一层元素倒置:
%(reverse '((a b) (c d) (e f)))
%--->((e f) (c d) (a b))
%
%3.nth  提取列表的第几个元素:
%(nth 0 '(a b c))----->A
%(nth 1 '(a (b c) d))--->(B C)  
%说明，在common-lisp中数数都是从0开始数的。
%
%4.nthcdr  cdr命令我们是知道的，nth就是做几次cdr命令。所以做0次就是原列表，做一次cdr等等。
%需要注意的就是：
%(cdr nil)--->nil
%也就是对空列表cdr还是空列表，所以如果cdr过头了就会得到nil，但是有一个例外，那就是dotted list。
%因为dotted list是以一个元素作结尾，这样将会导致错误。因为cdr不能对列表进行操作。
%(nthcdr 2 '(a b c))--->(c)
%
%5.last  last返回的是列表的最后一个cons cell结构。
%(last nil)--->nil
%对于正常的列表就是返回最后一个元素，不过是加了列表符号的。
%(last '(a b c))--->(c)
%对于dotted list则是所谓的最后一个cons cell：
%图片
%
%6.remove     remove就是把某个列表中出现的某个元素给移去。
%(remove 'a '(b a n a n a))--->(b n n)
%这个时候你们一定会像是局限于元素，还是局限于某个单元元素，还是列表中出现的任何地方的元素。
%最后结果如图片2所示：
%图片
%
%也就是说第一个参量只能是单元元素或者说是value,值。而针对的也只是后面列表中的top元素的值。将其移去。
%
%7
%列表作为集合：
%集合的概念我们在数学中已经了解得很清除了。lisp的括号非常方便表达集合，除了每一个item项目只出现一次要特别注意就是了。
%虽然下面对集合的几个函数对于不是作为集合的列表也可以操作，但最好还是严格定义。
%以下是针对集合的命令：
%member      intersection       union       set-difference     subsetp
%
%8.member   member函数的作用就是核对某个value值是不是在后面列表中。如果是那么返回真值，包括开始为真的那个值也包括后面的元素。是假那么返回nil。
%图片
%这个和remove是类似的，所以这个命令和严格的集合内部元素判断的定义还是有点差异的。
%
%9.intersection  交集
%10.union  补集
%11.set-difference  差集
%12.subsetp   判断第一个集合是不是第二个集合的子集，是就返回T，这里是确定的t。假返回nil。
%
%上面的交集补集差集就和集合的定义运算完全一致了，也就是第一个参量是一个列表的话，代表着一个整体对第二个集合进行考察。而这种操作是有意义的，而前面的remove member似乎都不包括这一情况。而9.10.11.12这几个命令必须是列表不能是元素。看来所有这些命令至少有一点是共同的，那就是第一个项目要某是列表要某是元素。
%
%图片
%
%13.用集合来解决一个小问题，输入一个名字，然后在这个名字的前面加上mr或者ms之类的。
%以后编程都要遵循以下两点，一是将一个大问题转化成一些小的问题小的函数，二是一次测试好一个函数。
%13.1 判断名字前面是不是有了title：
%图片
%13.2 判断性别：
%图片
%这个malep判断用的逻辑是--是确定是男性不是女性，femalep用的逻辑是确定是女性不是男性，中间还剩下了可能是男性可能是女性的那部分。
%13.3 give-title
%图片
%
%
%
%
%\chapter{C语言}
%\subsection{转义字符}
%\textbackslash a{} 响铃符 \hspace{4em} \textbackslash b{} 回退符 \hspace{4em} \textbackslash f{} 换页符\\
%\textbackslash n{} 换行符 \hspace{4em} \textbackslash r{} 回车符 \hspace{4em} \textbackslash t{} 横向制表符\\
%\textbackslash v{} 纵向制表符 \hspace{2em} \textbackslash \textbackslash{} 反斜杠\hspace{4em} \textbackslash ?{} 问号\\
%\textbackslash '{} 单引号  \hspace{4em} \textbackslash " 双引号 \hspace{4em} \textbackslash  ooo{} 八进制数\\
% \textbackslash xhh 十六进制数
%
%
%\section{helloworld项目}
%
%\subsection{库的搭建}
%
%\subsection{makefile基础}
%makefile文件里面主要有三种内容：
%%\vspace{1em}
%%    1.变量声明：
%%
%%        变量声明就是一种基本的严格字符替换的操作。
%%
%%        比如在前面声明了：objects=program.o foo.o utils.o
%%
%%        那么在后面出现的所有\$(objects)或者\$\{objects\}都会被自动替换成上面的那个字符序列，而且是严格替换，即不带空格的。
%%\vspace{1em}
%%      2.映射法则
%%\vspace{1em}
%%        3.命令：
%%
%%    映射法则和命令通常都是联合起来组成这样的结构形式：
%%
%%    target...   : prerequisites..
%%
%%             command
%%
%% 
%%
%%    可以简单地理解为通过prerequisites，也就是先决的依赖文件，采取后面描述的相应的命令（这里的命令都是linux里的shell命令）command之后（一般是）生成了文件target。命令的前面都要按以下tab建留一段空白来表示它是命令。
%%
%%    有的target后面并没有先决条件，也就是后面的命令是无条件执行的。
%%
%%    这个结构总的作用就是告诉make，target是不是out of date，具体视它的依赖文件而定，target不存在也视为out of date。然后就是如果过期了，那么更新，就是运行下面的命令来更新。
%    
%\subsection{gcc基础}
%
%\subsection{gdb的调试基础}
%
%\subsection{autoconf基础}
%
%%在/project/hello的主目录下面的makefile文件的内容如下：
%%
%%    prefix = /usr/local
%%
%%exec_prefix = $(prefix)
%%
%%bindir = $(exec_prefix)/bin
%%
%%
%%export prefix
%%
%%export exec_prefix
%%
%%export bindir
%%
%%
%%all clean  install uninstall :    
%%
%%             cd src && $(MAKE) $@
%%
%%
%%
%%.PHONY:  all clean   install uninstall
%%
%%
%%在/project/hello/src目录下面的makefile文件内容如下：
%%
%%
%%all: hello
%%
%%
%%hello: main.c
%%
%%         $(CC)  -o $@ main.c 
%%
%%
%%clean:
%%
%%         rm hello
%%
%%
%%
%%install:
%%
%%         install -d $(bindir)
%%
%%         install -m 0755 hello  $(bindir)
%%
%%
%%uninstall:
%%
%%         rm $(bindir)/hello 
%%
%%
%%.PHONY: all clean  install uninstall
%%
%%
%%我们等下详细说明，先看下运行情况：
%%
%%现在makefile支持这四个命令：make，make install ，make clean和make uninstall。
%%
%%我们从上图可以看出可以直接从终端调用我们生成的程序hello，然后返回“hello，the world！”。
%%
%%
%%    首先我们看主目录下的makefile文件，前面那部分是变量声明，这个等下还会说到。然后是export 变量，这个就是主目录下的主makefile文件可以使用这个命令，意思是将变量和子一级目录下的makefile共享。
%%
%%    然后我们看到
%%
%%all clean  install uninstall :
%%
%%         cd src && $(MAKE) $@
%%
%%
%%.PHONY:  all clean   install uninstall
%%
%%这实际上是一个跳转结构，首先介绍下.PHONY是个什么意思，前面说了每一个target默认都是一个待生成文件，但是.PHONY:后面跟着的target的意思是这些target不用生成文件。那么总的来说这里的all，clean，install，uninstall在这里是些没有依赖文件的不用生成最终target文件的执行命令了。这些执行命令就是前面说的make，make install ，make clean和make uninstall。make的意思实际上就是make all，这两个命令是没有区别的。
%%
%% 
%%
%%    然后我们看到命令，cd src这个很容易理解，就是跳转到src目录中去了。然后&&符号的意思是逻辑与，即前一命令执行完之后再执行后面的命令。而后面的$(MAKE)可能是一个具有系统默认值的变量，在这里应该就是make。而$@符号的意思则是指代当前的target。比如说我现在make clean ，那么命令最终就成了这个样子：
%%
%%    cd src &&make clean
%%
%%    然后下一个make clean的命令实际上是对src子目录下的makefile文件说的，我们看到这里简单的：
%%
%%clean:
%%
%%    rm hello
%%
%%即把生成的可执行文件hello删掉即可。
%%
%% 
%%
%%然后我们再来看子目录下那个makefile文件如何处理make all 命令：
%%
%%all: hello
%%
%%
%%hello: main.c
%%
%%    $(CC)  -o $@ main.c 
%%
%%我们看到，这里首先说明all依赖于hello，然后hello依赖于main.c，而要生成或者更新hello的话需要执行下面的命令：
%%
%%cc -o hello main.c 
%%
%%上面的$(CC)也是具有系统默认值的变量，就是cc，不过在GNU/LINUX体系下可能调用的是gcc工具。后面的选项-o的意思是编译连接然后生成后面的那个名字的文件。名字在这里就是hello。
%%
%%
%%然后我们再来看make install命令执行的情况：
%%
%%install:
%%
%%install -d $(bindir)
%%
%%install -m 0755 hello  $(bindir)
%%
%%前面说过了这个变量是继承自主目录makefile文件中的定义，然后翻译出来$(bindir)就是/usr/local/bin。linux系统在终端可以直接调用的命令存放点有两个位置，另外的一个是/usr/bin。/usr/local文件夹内部的结构和/usr内部的结构非常相似。似乎讲起来/usr是供系统内部的软件使用的空间，但这个规矩并不是死的。
%%
%%
%%uninstall命令我们看到就是一个删除对应位置hello文件的操作。所以现在就把linux中的install命令讲讲就可以了。
%%
%%    第一个install命令接着-d的选项的意思就是目录确认，在这里我觉得有点多余。
%%
%%    第二个install命令接着-m的选项的意思就是把hello复制到指定的目录中去，然后相应文件也就是hello文件的权限设置成为0755.关于权限我觉得在这里似乎也没有什么好说的。在这里用第二个install命令就可以搞定了，过程是复制，加权限，更新时间戳。
%\chapter{linux知识}
%
%\section{在emacs之上}
%好吧，久负盛名的编辑器，我给它单独开了一个分支。
%\subsection{初识emacs}
%\begin{enumerate}
%\item 在emacs中进入终端：（按下左边）alt  +  x  然后输入eshell
%\item 退出eshell：输入exit
%\item 在emacs中进入common-lisp的交互界面：（左边）alt + x +slime
%\item 退出slime模式：按下逗号，然后再按下q 即可
%\item emacs的窗口布局调整：按下左边的ctrl+x，然后再输入1：那么只有一个窗口。按下ctrl+x，然后再输入2：那么在当前窗口下面会再分出一个窗口。而按下ctrl+x，然后在输入3：那么就是在当前窗口右边再分出一个窗口。
%\item 用emacs打开某个文件和编辑之后保存文件：按下ctrl+x，然后在按下ctrl+f，这个时候我们看到emacs最下面显示目前所处路径为～/，然后我们在下面接着填上我们想要打开的文件的目录地址，enter之后我们就看到emacs打开该文件了。然后保存文件：按下ctrl+x ，再按下ctrl+s （前面的f是find的意思，这里的s是save的意思。）如果强行退出emacs的话如果还有没保存的buffer它也会提醒的。
%\end{enumerate}
%
%
%
%
%
%\subsection{配置emacs的slime环境}
%\begin{enumerate}
%\item 首先安装commonlisp的一种编译器，这里以clisp为例子，其实sbcl等也是不错地：\\
%    sudo apt-get install clisp
%\item 安装cvs，然后通过cvs服务器下载最新的slime版本：\\
%    sudo apt-get install cvs
%    
%    cvs -d :pserver:anonymous:anonymous@common-lisp.net:/project/slime/cvsroot co slime
%\item 或者你也可以到slime官网上下载镜像文件，然后解压到你的主文件夹目录之下，\href{http://common-lisp.net/project/slime/}{slime官网}
%\item 配置.emacs文件，加上如下代码：
%\begin{xverbatim}{lisp}
%;;; Always do syntax highlighting
%(global-font-lock-mode 1)
%
%;;; Also highlight parens
%(setq show-paren-delay 0
%      show-paren-style 'parenthesis)
%(show-paren-mode 1)
%;;;下面是scheme的设置部分
%;;; This is the binary name of my scheme implementation
%(setq scheme-program-name "mzscheme")
%
%;;;下面是clisp的slime设置部分
%(add-to-list 'load-path "~/slime")
%(require 'slime)
%(add-hook 'lisp-mode-hook (lambda () (slime-mode t)))
%(add-hook 'inferior-lisp-mode-hook (lambda () (inferior-slime-mode t)))
%;; Optionally, specify the lisp program you are using. Default is "lisp"
%(setq inferior-lisp-program "clisp") 
%(slime-setup '(slime-fancy))
%\end{xverbatim}
%\item 最后进入emacs，按下alt+x，输入slime，即进入common-lisp的交互环境。
%\item 如果你发现加载出现asdf库错误，可能是你以前的slime旧配置作怪,清除以前的旧配置可能有效:\\
%    sudo apt-get purge slime
%\end{enumerate}
%
%
%\subsection{配置emacs的scheme环境}
%\begin{enumerate}
%\item 在ubuntu软件中心安装GNU emacs23.或者终端下输入命令：\\
%    sudo apt-get install emacs23
%\item 安装相应的scheme的编译器,这里推荐guile：\\
%    sudo apt-get install guile-2.0
%\item cd \~{} 
%\item sudo gedit .emacs
%\item 在.emacs文件中添加如下代码：\\
%\begin{xverbatim}{lisp}
%;;; Always do syntax highlighting
%(global-font-lock-mode 1)
%
%;;; Also highlight parens
%(setq show-paren-delay 0
%      show-paren-style 'parenthesis)
%(show-paren-mode 1)
%\end{xverbatim}
%这段代码是语法高亮和括号提示，同样可以作用于其他lisp系的语言，所以可以放在emacs配置文件的最上面。
%\item 然后加上这段专门配置scheme的代码：\\
%\begin{xverbatim}{lisp}
%;;;下面是scheme的设置部分
%
%;; This is the binary name of my scheme implementation
%(setq scheme-program-name "guile")
%\end{xverbatim}
%\item 打开emacs，然后按下alt+x，然后输入run-scheme，即进入sheme的交互环境了。
%\item 退出命令：\\
%    (exit)
%\end{enumerate}
%
%\subsection{emacs的其他配置}
%这里还有一个设置背景色和支持复制粘贴快捷键的配置，还有其他的很多配置以后再慢慢摸索吧。
%\begin{xverbatim}{lisp}
%;;;设置背景色
%(setq default-frame-alist
%  '((tool-bar-lines . 0)
%    (menu-bar-lines . 1)
%    (background-color . "cornsilk")))
%   ;;; 左边显示行数
%(global-linum-mode 1)
%;;;支持复制粘贴快捷键
%(cua-mode 1) 
%\end{xverbatim}
%
%
%
%\chapter{其他资料临时存放地}
%1.刘鑫等人翻译的python入门教程。for python3
%2.主要参考书籍：http://ishare.iask.sina.com.cn/f/18565630.html


%这里空一行

\end{common-format}
\end{document}



