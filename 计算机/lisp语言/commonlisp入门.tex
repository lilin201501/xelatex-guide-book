% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig scalefig xverbatim

\documentclass[11pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{11pt}
\newif\ifphone
\phonefalse


\usepackage{myconfig}
\usepackage{mytitle}




\begin{document}
\frontmatter

\titlea{commonlisp}
\titleb{入门}
\titlec{一种良好的风格}
\author{万泽}
\authorinfo{作者：湖南常德人氏}
\editor{编者}
\email{a358003542@gmail.com}
\editorinfo{编者：}
\version{1.0}
\titleLB

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
这本小册子主要记录了我收集的关于commonlisp的入门知识。

%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter

\chapter{准备工作}
\section{xverbatim环境}
为了显示commonlisp的代码，现在xverbatim宏包建立的xverbatim环境中经过一些优化之后一切照旧，可选项129表示显示代码并执行并显示结果。但是命令行脚本执行commonlisp文件还是和repl-mode\footnote{read-eval-print-loop}有点区别的，最大的区别就是常规的如(+ 1 2)这样的输入没有任何输出信息的。为了克服这点，早期采取的是这样的形式。
\begin{xverbatim}[129]{lisp}
(format t "~&~s" (* 2 8) )
\end{xverbatim}
这里lisp是标识了等下要生成common-lisp文件的后缀名为lisp，然后染色方案识别为common-lisp。

这里的\verb+~&+表示确认等下的输出为新的一行。
这里的\verb+~s+表示等下输出一个内容，这个内容是后面表达式的eval之后的结果。

在早期说明一些基本的知识的时候我会采取这种形式，读者需要记住的是输出的结果就是(* 2 8)运行之后的结果。随著学习的深入，一切没必要显示出来的内部操作将不会采取这种形式了。

\section{emacs的commonlisp环境配置}
我现在是在ubuntu13.10的emacs24之下，安装\textbf{emacs24}运行sudo apt-get install emacs24安装即可。然后需要安装commonlisp的编译运行环境，推荐\textbf{sbcl}或者\textbf{clisp}，同样类似的用apt-get命令安装即可。记得以前要配置slime环境，需要经过一番周折。现在似乎只需要用apt-get命令安装slime即可。

测试运行情况就是进入emacs24，按住Alt键和X字母\footnote{在emacs中，Alt+X将调用一些外部命令，Ctrl+X将调用一些外部命令。}，然后输入slime。调配窗口的命令是Ctrl+X，然后输入数字\textbf{1}，这将只显示一个窗口。类似有数字\textbf{2}，生成上下两个窗口；数字\textbf{3}，生成左右两个窗口。

知识更新换代太快了，而我又是一个喜欢简洁的人，所以我在这里忍住谈论太多。只是简单提一下，在Ubuntu系统的主文件夹里面有个隐藏文件——\textbf{.emacs}。这个文件里面写著emacs用户自己的一些DIY。有一些配置可以在emacs主面板上设置，然后保存配置即可。

这里简单提一下我觉得这里有用的配置：\\
\verb+(global-linum-mode 1)+\\
左侧显示行数\\
\verb+(cua-mode 1)+\\
支持Ctrl+C，Ctrl+V复制粘贴快捷键\\
\verb+(setq show-paren-delay 0 show-paren-style 'parenthesis)+\\
\verb+(show-paren-mode 1)+\\
高亮显示括号\\
\verb+(setq scheme-program-name "guile")+\\
这个也在这里说了，通过apt-get可以直接安装guile软件——scheme语言的编译器。scheme语言和common-lisp语言很类似，同时在说明编程语言思想上更加直白和透彻，推荐有空接触下。通过上面这一行代码，就可以在emacs上运行Alt+X run-scheme直接调用guile模式来运行scheme的repl-mode了。

\section{emacs的小技巧}
\subsection{调出前面输入的命令}
按住Ctrl和使用方向键即可。

\chapter{基础知识}
\section{第一谈}

Common-lisp以下全部都简称lisp，lisp的数据类型分为符号和数字\cite{touretzky2013common}。数字又分为整数integer、实数floatingpoint和ratio分数三类。其中分数都会自动化为最小分母的形式。比如：
\begin{xverbatim}[129]{lisp}
(format t  "~&~s" (/ 1 2))
(format t  "~&~s" (/ 2 4))
\end{xverbatim}
同时我们看到1除以2并没有化成0.5之类的形式，这是lisp和其他程序语言很大的一个区别。 

Lisp中的T和nil表示逻辑的真值和假值，然后空表()也表示nil，而其他所有东西在逻辑上都被视作真值。
 
一些逻辑上的判断函数，numberp判断是否是数字，symbolp判断是否是符号。Equal判断是否两个值相等。zerop判断是否是0，oddp判断是否是奇数，evenp判断是否是偶数。还有小于号也是一个判断函数<，还有大于号>。not在逻辑上反值。
 
举些例子：
\begin{xverbatim}[129]{lisp}
(format t "~&~s"  (numberp 2))
(format t "~&~s" (symbolp 'dog2-dfdf))
(format t "~&~s"  (equal 'dog 'dog))
(format t "~&~s"   (< -4 -3))
(format t "~&~s" (oddp 3))
(format t "~&~s" (not '(a d c)))
\end{xverbatim}
通过上面的例子我们注意到lisp语言的符号几乎是没有什么限制的，除了数字之外就是符号。然后数字前面可以加引用号’，也可以不加。不过符号就一定要加，否则会出错。还有就是即使列表这样的东西在lisp中通过not操作也会返回nil值。
 
lisp的一些基本内置函数：
\verb|+  -  *  /  abs    sqrt| 
前面的加减乘除的输入参数可以是任意的输入参数。具体就是第一个数连续加（减 或者乘除）上后面的数。不过加减乘只有一个参数的时候结果是什么都好想想，

在电脑中cpu的工作可以理解成为硬件化的某些基本函数，比如加减之类的。而其他我们接触到的所有函数都只是输入指针，输出指针。而这些指针的具体内存地址并不永久存在，只是暂时存在在某个寄存器或者堆栈上（因为具体的内存地址也是需要处理之后生成的一个结果）。也就是所有复杂的函数都是架构在最基本的几个硬件函数至上的，所不同的是这些硬件函数会具体根据不同的地址输入不同的待处理信息或者在不同的地址上输出处理后的信息。

lisp，list processor，中文名字就是链表处理语言。显然，list就是里面最基本的数据结构，而其他所有的数据结构都是基于list架构出来的。一个链表的结构非常简单，就是一个cons cell结构，这个结构由car指针地址和cdr指针地址两个指针地址组成。

现在演示下(a (b c) d)的结构
 
现在我们把这个列表简单地命名为list：
\begin{xverbatim}[129]{lisp}
(setq list '(a (b c) d))
(format t "~&~s"  list )
(car list)
\end{xverbatim}
在这里发生的什么呢？car函数是如此的基本，在这里list传递给别人的也不是别的，就是它指向那个(a (b c) d)的地址。然后car函数根据这个地址顺藤摸瓜找到了第一个地址，然后根据这个地址找到那段内存的数据，然后返回回来。所以原子（atom）类型的符号是实实在在的一个存储在内存中的信息，这段信息需要用基本函数（primitive function）quote，也就是前面加个’来调用出来。而像上面list通过setq定义的符号就成为了一个变量，这个变量和list不同只是一个指针地址的结构，声明他就自动调用它所映射的在内存中的信息。

那么cdr函数的工作也就简单了，根据list所提供的地址，顺藤摸瓜找到第一个链表的cdr地址，然后创造一个内存，这个内存中的地址信息指向那个cdr地址。然后将这个值作为返回结果。记住所有的括号在内存中都是不存在，而cdr返回后面部分内容只是基于链表的向后而不能向前查询的内在机制决定的。

关于car，cdr的诸多衍生如什么caddr之类的就不多说了，记住从右向左看就是的了。

前面说了再复杂的list结构都是由最基本的cons cell 组成的。所谓cons结构，这个基元细胞就是car地址加上cdr地址这样的组合形式。
那么内置基本函数cons的功能就是接受两个地址，第一个地址存入car地址，第二个地址存入cdr地址。这样形成一个cons cell的基元结构。
而内置基本函数list就是迭代调用cons函数的结果。

%CL-USER 28 : 6 > (list 'a 'b 'c)
%(A B C)
% 
%CL-USER 30 : 6 > (cons 'a (cons 'b (cons 'c nil)))
%(A B C)
%所以cons函数首先将c的引用地址和nil组合成一个cons cell 然后返回这个cell的引用地址，然后是b的引用地址和那个返回地址，然后是a的地址和那个返回地址。这样依次形成这样的链表结构：
% 
%图片
%就是如上图所示的过程，然后最后返回这个链表的引用地址。
%下面是一些特殊情况的例子：
%CL-USER 31 : 6 > (length '(a b c))
%3
% 
%CL-USER 32 : 6 > (length nil)
%0
% 
%CL-USER 33 : 6 > (car nil)
%NIL
% 
%CL-USER 34 : 6 > (cdr nil)
%NIL
% 
%还有一些基本的函数，first返回第一个元素，second，third，rest。
%还有两个判断函数，listp和consp。这两个函数大多数情况都一样的，遇到列表返回T，不是返回nil。但是有以下特殊情况。
%CL-USER 36 : 6 > (listp nil)
%T
% 
%CL-USER 37 : 6 > (consp nil)
%NIL
% 
%CL-USER 38 : 6 > (atom nil)
%T
%CL-USER 40 : 6 > (cons nil nil)
%(NIL)
% 
%CL-USER 41 : 6 > (list nil nil)
%(NIL NIL)
%这之间的区别就在于list内置的最后以下会自动加上一个nil，然后nil是空表所以listp判断为真，但是nil并不是cons cell 结构，它是一个原子量。nil比较特殊。
% 

\section{基本流程控制}
125页
%2.lisp用于逻辑线路控制的命令：if，and，or，cond。
%
%2.1  if主要用于逻辑线路不太复杂的情况，用法是：
%（if      逻辑判断部分    是真则执行我   是假则执行我）
%或者只有三个部分，那么就是默认是假的时候什么都不做，即nil。
%
%
%2.2 and 和or
%and是先evaluate一个，如果是真，那么going on to evaluate，如果是nil，那么返回nil。
%and还有一个有趣的性质，那就是如果都为真，那么最后返回的不是T，而是最后那个信息的结果。
%（and 'one  'two 'three)--->three
%
%or是先evaluate一个，如果是真就report，同样返回这个信息的结果，如果是nil，keep going on to search。
%(or nil nil 'apple 'blue)---->apple
%
%or可以建立事物的组合关系，这样对应真实世界的空间关系。也就是抽取一个属性，和某个逻辑判断元比对后，返回这个属性。
%and可以建立事物的序列关系，对应真实世界的时间关系。即依次对比，直到反馈最后一个属性。
%
%2.3  .side effect ，pure lisp 只有cons car cdr equal atom cond lambda define quote eval + - * / 这些命令
%这些命令没有副效应，即不会改变机器的状态。但是其他的宏命令会改变机器的状态。上面的setf就是。
%比如random是一个产生随机数的函数，它为了保证每次运行它都制作一个随机数，它实际上改变了random number generator。
%（random 5）----->从0随机到5，包括0不包括5.
%
%2.4 cond则适用于那些特别大型的逻辑线路。
%下面是一个随机数的条件程序：
% 
%图片
% 
%3.setf ，defun，let和let*
%还有一个setq和setf差不多的，不过一般用setf。
%setf宏命令就是给一个变量variable赋值，通常为global variable。
%（setf  vowels  '(a b c ))
%
%4.let 主要用于创造local  variables.用法如下：
% 
%图片
%上面就是用let 给sum赋值，然后sum是local  variale,即他的存在只在let 这个括号内。
%
%5.let 在body中遇到不认识的变量了，首先在自己内部找，如果找不到，那么在global variable中找。
%然后没定义一个defun其函数内部都有自己独立的语境，即用自己的局域变量，找不到就用广义变量。还找不到就说出现错误。
% 
%图片
%上面例子就显示了我额外加了一个z程序是如何处理的。
%
%6.let*和let的区别就是一次只运算赋值一个本地变量，然后再第二个。也就是说如果第二个的赋值依赖于第一个的话，那么比如用let*。比如说我先赋值r，然后赋值面积等于2 * pai*r，那么第二个赋值就依赖于第二个。这种情况用let就会出现错误。但是编程一般用let，为了竟可能减少程序间的依赖关系，方便理解。

%
%8.cons ，list 还有append。
%cons这个命令就是创建cons cell结构，通常用于把元素添加到列表头上。
% 整个过程是先创造一个cons cell，第一个地址指向第一个元素，第二个地址指向第二个元素。
% 
%图片
%
%需要特别说明的就是那个中间加点的结构，叫什么dotted list，意思是它不是以nil结尾的。而是以一个值。
%
%list这个命令好理解点，就是加了一个括号。也就是总是ending in nil。因为括号就是意味这一个标准的cons cell 结构 而且以nil结束。
%
%append命令作用过程是首先复制第一个列表作为input信号，然后将其尾部指向到第二个元素中。
%因此append命令第一个元素必须是列表，否则会出现错误。
%(append 'a '(b c))--->error!!
% 
%图片
%
%9.给列表后面添加一个元素：
% 
%图片
% 
%
% 
\section{更多的列表操作}
%1.更多的列表操作函数：
%reverse               nth                        nthcdr                  last           remove
%上面四个函数都是创建了一个新的列表，原列表对应的变量的值并没有改变。
%
%2.reverse  将列表第一层元素倒置:
%(reverse '((a b) (c d) (e f)))
%--->((e f) (c d) (a b))
%
%3.nth  提取列表的第几个元素:
%(nth 0 '(a b c))----->A
%(nth 1 '(a (b c) d))--->(B C)  
%说明，在common-lisp中数数都是从0开始数的。
%
%4.nthcdr  cdr命令我们是知道的，nth就是做几次cdr命令。所以做0次就是原列表，做一次cdr等等。
%需要注意的就是：
%(cdr nil)--->nil
%也就是对空列表cdr还是空列表，所以如果cdr过头了就会得到nil，但是有一个例外，那就是dotted list。
%因为dotted list是以一个元素作结尾，这样将会导致错误。因为cdr不能对列表进行操作。
%(nthcdr 2 '(a b c))--->(c)
%
%5.last  last返回的是列表的最后一个cons cell结构。
%(last nil)--->nil
%对于正常的列表就是返回最后一个元素，不过是加了列表符号的。
%(last '(a b c))--->(c)
%对于dotted list则是所谓的最后一个cons cell：
%图片
%
%6.remove     remove就是把某个列表中出现的某个元素给移去。
%(remove 'a '(b a n a n a))--->(b n n)
%这个时候你们一定会像是局限于元素，还是局限于某个单元元素，还是列表中出现的任何地方的元素。
%最后结果如图片2所示：
%图片
%
%也就是说第一个参量只能是单元元素或者说是value,值。而针对的也只是后面列表中的top元素的值。将其移去。
%
%7
%列表作为集合：
%集合的概念我们在数学中已经了解得很清除了。lisp的括号非常方便表达集合，除了每一个item项目只出现一次要特别注意就是了。
%虽然下面对集合的几个函数对于不是作为集合的列表也可以操作，但最好还是严格定义。
%以下是针对集合的命令：
%member      intersection       union       set-difference     subsetp
%
%8.member   member函数的作用就是核对某个value值是不是在后面列表中。如果是那么返回真值，包括开始为真的那个值也包括后面的元素。是假那么返回nil。
%图片
%这个和remove是类似的，所以这个命令和严格的集合内部元素判断的定义还是有点差异的。
%
%9.intersection  交集
%10.union  补集
%11.set-difference  差集
%12.subsetp   判断第一个集合是不是第二个集合的子集，是就返回T，这里是确定的t。假返回nil。
%
%上面的交集补集差集就和集合的定义运算完全一致了，也就是第一个参量是一个列表的话，代表着一个整体对第二个集合进行考察。而这种操作是有意义的，而前面的remove member似乎都不包括这一情况。而9.10.11.12这几个命令必须是列表不能是元素。看来所有这些命令至少有一点是共同的，那就是第一个项目要某是列表要某是元素。
%
%图片
%
%13.用集合来解决一个小问题，输入一个名字，然后在这个名字的前面加上mr或者ms之类的。
%以后编程都要遵循以下两点，一是将一个大问题转化成一些小的问题小的函数，二是一次测试好一个函数。
%13.1 判断名字前面是不是有了title：
%图片
%13.2 判断性别：
%图片
%这个malep判断用的逻辑是--是确定是男性不是女性，femalep用的逻辑是确定是女性不是男性，中间还剩下了可能是男性可能是女性的那部分。
%13.3 give-title
图片




\bibliographystyle{unsrt}
\bibliography{references/\jobname}
%这里空一行

\end{common-format}
\end{document}



